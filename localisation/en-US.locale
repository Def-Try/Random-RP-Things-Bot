{
	"generic": {
		"yes": "yes",
		"no": "no",
		"here": "here",
		"banned_from_command": "You are banned from this command."
	},
	"cog": {
		"basic": {
			"info": {
				"desc": "Basic commands cog. Provides, well, basic functionality - /help, /reload_cogs, /ping commands.",
				"brief": "Basic commands"
			},
			"commands": {
				"help": {
					"name": "help",
					"desc": "Listing of all commands with their descriptions and examples.",
					"options": {
						"command": {
							"name": "command",
							"desc": "Command to get help on."
						},
						"cog": {
							"name": "cog",
							"desc": "Cog to get (command) help on"
						}
					}
				},
				"reload_cogs": {
					"name": "reload_cogs",
					"desc": "Reload bot's extensions(aka cogs)."
				},
				"ping": {
					"name": "ping",
					"desc": "Return latency status for bot."
				}
			},
			"answers": {
				"help": {
					"hidden": "...{amount} more command(s) hidden...",
					"title": "Bot Help",
					"desc": "{mention}, formely known as `googer's random things bot` is a bot based on modularity. Most of it's components can be removed or replaced without need for code editing, which makes it perfect for implementing both small and big commands without affecting others, partly which is why it's named `random things` bot.",
					"command": "Command `/{command}`",
					"elements": {
						"desc": "Description",
						"parameters": "Parameters",
						"cog": "Cog"
					},
					"error": {
						"unknown_cog": "Unknown cog. Maybe you made a typo? Make sure to type in exact name of cog - it's case-sensitive!",
						"unknown_command": "Unknown command. Maybe you typed in wrong cog, or command does not exist. You can use both 'internal' and visual name of command."
					}
				},
				"ping": {
					"title": "Ping (latency status)",
					"desc": "pong!",
					"dwpl": "Discord Websocket Protocol Latency (DWPL)",
					"unit": "ms"
				},
				"reload_cogs": {
					"in_progress": "Reloading...",
					"title": "Cogs reloaded",
					"description": "`{errored}` errored, `{success}` successfully",
					"cog": {
						"error": "[ERROR ]",
						"ok": "[  OK  ]",
						"name": "`{status}` - {name}",
						"desc": "Unloaded/loaded in: `{unload}ms`/`{load}ms`"
					}
				}
			}
		},
		"actions_commands": {
			"info": {
				"desc": "Cog that provides action commands. Commands that respond with fancy embed with gif of action.",
				"brief": "Action commands"
			},
			"command_group": {
				"name": "action",
				"desc": "Slash-commands that send fancy embed with gif of your action."
			},
			"commands": {
				"pat": "pat",
				"hug": "hug",
				"cuddle": "cuddle",
				"handshake": "handshake",
				"bite": "bite",
				"highfive": "highfive",
				"kiss": "kiss",
				"poke": "poke",
				"slap": "slap",
				"handhold": "handhold",
				"kick": "kick",
				"punch": "punch",
				"tickle": "tickle",
				"feed": "feed",
				"stare": "stare",
				"wave": "wave",
				"cry": "cry",
				"blush": "blush",
				"dance": "dance",
				"happy": "happy",
				"laugh": "laugh",
				"shrug": "shrug",
				"sleep": "sleep",
				"smile": "smile",
				"think": "think",
				"nod": "nod",

				"action": {
					"desc": "Self-explanatory.",
					"options": {
						"other": {
							"name": "user",
							"desc": "User that you want to do action to"
						}
					}
				},

				"portal": {
					"name": "portal_begin",
					"desc": "Start or finish opening of a portal."
				},
				"portal_cancel": {
					"name": "cancel_portal",
					"desc": "Cancel opening of a portal."
				}
			},
			"answers": {
				"action": {
					"name": "Action",
					"pat": {
						"other": "{member} pats {other}",
						"self": "{member} pats themselves",
						"bot": "{member} pats me"
					},
					"hug": {
						"other": "{member} hugs {other}",
						"self": "{member} hugs themselves",
						"bot": "{member} hugs me"
					},
					"cuddle": {
						"other": "{member} cuddles {other}",
						"self": "{member} cuddles themselves",
						"bot": "{member} cuddles me"
					},
					"handshake": {
						"other": "{member} shakes {other}'s hand",
						"self": "{member} shakes theirselves hand",
						"bot": "{member} shakes my hand"
					},
					"bite": {
						"other": "{member} bites {other}",
						"self": "{member} bites themselves",
						"bot": "{member} bites me"
					},
					"highfive": {
						"other": "{member} gives {other} a high five",
						"self": "{member} gives themselves a highfive",
						"bot": "{member} gives me a highfive"
					},
					"kiss": {
						"other": "{member} kisses {other}",
						"self": "{member} kisses themselves",
						"bot": "{member} kisses me"
					},
					"poke": {
						"other": "{member} pokes {other}",
						"self": "{member} pokes themselves",
						"bot": "{member} pokes me"
					},
					"slap": {
						"other": "{member} slaps {other}",
						"self": "{member} slaps themselves",
						"bot": "{member} slaps me"
					},
					"handhold": {
						"other": "{member} holds {other}'s hand",
						"self": "{member} holds theirselves hand",
						"bot": "{member} holds my hand"
					},
					"kick": {
						"other": "{member} kicks {other}",
						"self": "{member} kicks themselves",
						"bot": "{member} kicks me"
					},
					"punch": {
						"other": "{member} punches {other}",
						"self": "{member} punches themselves",
						"bot": "{member} punches me"
					},
					"tickle": {
						"other": "{member} tickles {other}",
						"self": "{member} tickles themselves",
						"bot": "{member} tickles me"
					},
					"feed": {
						"other": "{member} feeds {other}",
						"self": "{member} feeds themselves",
						"bot": "{member} feeds me"
					},
					"stare": {
						"other": "{member} stares at {other}",
						"self": "{member} stares at themselves",
						"bot": "{member} stares at me",
						"none": "{member} stares at something"
					},
					"wave": {
						"other": "{member} waves to {other}",
						"self": "{member} waves to themselves",
						"bot": "{member} waves me",
						"none": "{member} waves"
					},
					"cry": {
						"self": "{member} cries"
					},
					"blush": {
						"self": "{member} blushes"
					},
					"dance": {
						"self": "{member} dances"
					},
					"happy": {
						"self": "{member} is just happy"
					},
					"laugh": {
						"self": "{member} laughes"
					},
					"shrug": {
						"self": "{member} shrugs"
					},
					"sleep": {
						"self": "{member} sleeps"
					},
					"smile": {
						"self": "{member} smiles"
					},
					"think": {
						"self": "{member} think"
					},
					"nod": {
						"self": "{member} nods"
					},
					"portal_cancel": "Portal opening canceled.",
					"portal": {
						"step1": "Great! Now repeat this command in channel you want to open portal.",
						"step2": "Done! Portal's opened",
						"opening": {
							"title": "Portal creation",
							"from": "{member} opens a portal to {channel}!",
							"to": "A portal opens here from {channel}!"
						}
					}
				}
			}
		},
		"gif_related": {
			"info": {
				"desc": "Cog that provides commands that are related to gifs in any way.",
				"brief": "Commands related to gifs"
			},
			"command_group": {
				"name": "gif",
				"desc": "Slash-commands that are related to gifs in any way."
			},
			"commands": {
				"findgif": {
					"name": "find_gif",
					"desc": "Find gif by one of categories. Powered by nekos.best API.",
					"options": {
						"category": {
							"name": "category",
							"desc": "Gif category to find."
						}
					}
				}
			},
			"answers": {
				"findgif": {
					"invalid_category": "Wrong category: should be one of next: {categories}",
					"title": "Gif"
				}
			}
		},
		"mnlcog": {
			"info": {
				"desc": "Cog that integrates MnL esolanguage into discord. See more on that at https://github.com/Def-Try/MnLEsolang",
				"brief": "MnL commands."
			},
			"command_group": {
				"name": "mnl",
				"desc": "MnLCore slash-commands."
			},
			"commands": {
				"init": {
					"name": "init",
					"desc": "Initialise MnLEngine"
				},
				"config": {
					"name": "config",
					"desc": "Configure MnLEngine"
				},
				"run": {
					"name": "run",
					"desc": "Run code in MnLEngine"
				}
			},
			"answers": {
				"not_ready": "MnLEngine is not ready!",
				"init": {
					"already_initialised": "MnLEngine was ready already!",
					"ready": "MnLEngine is ready!"
				},
				"config": {
					"persisting_globals": {
						"true": "Variables will persist between runs.",
						"false": "Variables will not persist between runs."
					}
				},
				"run": {
					"ok": {
						"no_output": "Running complete!",
						"with_output": "Running complete!\nOutput:\n```\n{output}\n```"
					},
					"mnl_error": {
						"no_output": "There was an error while running your code: {error}.",
						"with_output": "There was an error while running your code: {error}.\nOutput:\n```\n{output}\n```"
					},
					"fatal_error": {
						"no_output": "Fatal core error while running: {error}.",
						"with_output": "Fatal core error while running: {error}.\nOutput:\n```\n{output}\n```"
					},
					"timed_out": {
						"no_output": "Running has taken more than {timeout} seconds.",
						"with_output": "Running has taken more than {timeout} seconds.\nOutput:\n```\n{output}\n```"
					}
				}
			}
		},
		"rp_utils": {
			"info": {
				"desc": "Cog that provides various RP utilities, like auto-afk-ping, offtopic messages cleanup, etc...",
				"brief": "RP utilities"
			},
			"command_group": {
				"name": "rp_utils",
				"desc": "Utils for help, moderating, and doing RP."
			},
			"commands": {
				"clean_offtopic": {
					"name": "clean_offtopic",
					"desc": "Clean offtopic messages in this channel"
				},
				"init_rp_channel": {
					"name": "init_rp_channel",
					"desc": "Mark this channel as RP channel."
				}
			},
			"answers": {
				"clean_offtopic": {
					"message": {
						"_1": "{x} messages will be deleted.",
						"_2..4": "{x} messages will be deleted.",
						"_5..9+0": "{x} messages will be deleted.",
						"HOWTHEFUCK": "{x} messages will be deleted."
					},
					"audit": "Removing offtopic messages from RP channel (message prefix is one of {prefixes})"
				},
				"user_afk": "*{user} has a blank, distracted look, and {user} does not react to anything at all. Perhaps {user} will come out of this state soon.*",
				"init_rp_channel": {
					"ok": "RP channel initialised",
					"already_initialised": "This channel is already initialised as an RP channel"
				}
			}
		},
		"interchat": {
			"info": {
				"desc": "Interchat is a cog that basically connects two different channels with webhooks and keeps them up-to-date with each other by syncing messages. Interchat can be opened by anyone who has address of channel where you want to open it.",
				"brief": "Interchat commands and hooks"
			},
			"command_group": {
				"name": "interchat",
				"desc": "Interchat. Allow for messages to be sent between different channels."
			},
			"commands": {
				"begin": {
					"name": "begin",
					"desc": "Open an interchat. You must have an address of server channel in order to open it.",
					"options": {
						"address": {
							"name": "address",
							"desc": "Address of channel where you want to open interchat."
						}
					}
				},
				"bind": {
					"name": "bind",
					"desc": "Bind this channel to an interchat hub.",
					"options": {
						"address": {
							"name": "address",
							"desc": "Address of hub where you want to bind interchat."
						}
					}
				},
				"unbind": {
					"name": "unbind",
					"desc": "Unbind this channel from an interchat hub.",
					"options": {
						"address": {
							"name": "address",
							"desc": "Address of hub from where you want to unbind interchat."
						}
					}
				},
				"destroy_hub": {
					"name": "destroy_hub",
					"desc": "Unbind all bound interchat channels and free hub address."
				},
				"end": {
					"name": "end",
					"desc": "End current interchat communication in this channel."
				},
				"address": {
					"name": "address",
					"desc": "Get an address of a channel this command was executed in."
				},
				"address_hub": {
					"name": "address_hub",
					"desc": "Get an address of a channel as a hub this command was executed in."
				},
				"info": {
					"name": "info",
					"desc": "Get information about interchat connection in this channel"
				}
			},
			"answers": {
				"getaddress": "Address of this channel is {address}",
				"getaddresshub": "Address of this channel as a hub is {address}",
				"begin": {
					"incoming": "Incoming interchat connection requested",
					"outgoing": "Initiated outgoing interchat connection",
					"fail": {
						"not_found": "Unable to trace this address to channel. Maybe you made a typo?",
						"same_channel": "You can't open interchat to the same channel you are in!",
						"already_open": "There is already an open interchat in one or both of endpoints!"
					}
				},
				"bind": {
					"success": "OK, bind to hub was successful",
					"already_bound": "We are already bound to this hub!",
					"is_a_hub": "This channel IS a hub!",

					"incoming": "Channel joined this hub.",
					"outgoing": "Bound to interchat hub."
				},
				"end": {
					"incoming": "Incoming interchat connection closed by side \"{side}\"",
					"outgoing": "Outgoing interchat connection closed by side \"{side}\"",
					"fail": {
						"permanent_tunnel": "Unable to close permanent tunnel.",
						"not_opened": "No interchat connection found in this channel."
					}
				},
				"info": {
					"title": "Interchat Info",
					"online": "Found interchat tunnel open in this channel.",
					"offline": "No open interchat connection in this channel found...",
					"started": "Started at",
					"our_side": "Our side",
					"incoming_to": "Incoming to",
					"outgoing_from": "Outgoing from",
					"permanent": "Is permanent?",
                    "receiver_side": "Receiver side",
                    "opener_side": "Opener side",
                    "hub": {
                    	"incoming_to": "Incoming to hub"
                    }
				}
			}
		}
	}
}
